# -*- coding: utf-8 -*-
"""MyMusicRecommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UiGaqGetWesU30Qf4Y2cXV5qNqwtqGCP
"""

!pip install spotipy

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import pandas as pd
import time

# Set up your Spotify client credentials
client_id = "33a98332e9c743cb86e1fb85a6669047"
client_secret = "f846c1469df54735bdb7a0a80ec89f67"
client_credentials_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

def fetch_tracks_by_genre(genre, limit=50):
    """
    Searches Spotify for tracks by genre.
    Returns a list of track metadata dictionaries.
    """
    results = sp.search(q=f"genre:{genre}", type="track", limit=limit)
    tracks = results['tracks']['items']
    track_data = []
    for track in tracks:
        # Sometimes there might be missing data; handle it gracefully.
        track_data.append({
            'track_id': track.get('id'),
            'track_name': track.get('name'),
            'artist': track['artists'][0].get('name') if track.get('artists') else None,
            'album_name': track['album'].get('name') if track.get('album') else None,
            'popularity': track.get('popularity'),
            'release_date': track['album'].get('release_date') if track.get('album') else None
        })
    return track_data

# Define genres you want to collect (you can expand this list)
genres = ['pop', 'rock', 'hip-hop']
all_tracks = []

for genre in genres:
    print(f"Fetching tracks for genre: {genre}")
    try:
        tracks = fetch_tracks_by_genre(genre, limit=50)
        all_tracks.extend(tracks)
        time.sleep(1)  # add a small delay to be safe from rate limits
    except Exception as e:
        print(f"Error fetching genre {genre}: {e}")

# Create a DataFrame from the collected data
df_tracks = pd.DataFrame(all_tracks)
print("Collected tracks:", df_tracks.shape)
df_tracks.head()

# Save the dataset for later use
df_tracks.to_csv("spotify_tracks.csv", index=False)
print("Dataset saved to spotify_tracks.csv")

#Preprocessing the Data
# Load the dataset
df = pd.read_csv("spotify_tracks.csv")
print("Dataset loaded:", df.shape)
df.head()

# Clean the data if needed (e.g., drop rows with missing values)
df.dropna(subset=['track_name', 'artist', 'album_name'], inplace=True)

# Create a feature "soup" that combines track name, artist, album name, and even release date if desired.
def create_feature_soup(row):
    return f"{row['track_name']} {row['artist']} {row['album_name']} {row['release_date']}"

df['soup'] = df.apply(create_feature_soup, axis=1)
print("Feature soup created:")
print(df[['track_name', 'soup']].head())

#3. Building an Advanced Content-Based Recommendation Engine
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Vectorize the text in the 'soup' column
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(df['soup'])
print("TF-IDF matrix shape:", tfidf_matrix.shape)

# Compute the cosine similarity matrix
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
print("Cosine similarity matrix shape:", cosine_sim.shape)

# Save the cosine similarity matrix if needed
# You can use pickle to save the matrix for later fast lookup.
import pickle
with open("cosine_sim_matrix.pkl", "wb") as f:
    pickle.dump(cosine_sim, f)
print("Cosine similarity matrix saved.")

#Define a recommendation function that retrieves similar tracks:
def recommend_songs(track_index, num_recommendations=5):
    # Get pairwise similarity scores for the specified track index
    sim_scores = list(enumerate(cosine_sim[track_index]))
    # Sort the tracks by similarity score in descending order
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    # Exclude the track itself (first entry) and select top recommendations
    sim_scores = sim_scores[1:num_recommendations+1]
    recommended_indices = [i[0] for i in sim_scores]
    return df.iloc[recommended_indices][['track_name', 'artist', 'album_name', 'release_date']]

# Test the recommendation function for the first track
print("Recommendations for the first track:")
print(recommend_songs(0))

df_tracks.to_csv("spotify_tracks.csv", index=False)

import os
print("Current working directory:", os.getcwd())

!ls /content/spotify_tracks.csv

df_tracks.to_csv("spotify_tracks.csv", index=False)

import os
print("File exists:", os.path.exists("spotify_tracks.csv"))

from google.colab import files
files.download('spotify_tracks.csv')

